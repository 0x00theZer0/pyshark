<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="PyShark : Python packet parser using wireshark&#39;s tshark">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>PyShark</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/KimiNewt/pyshark">View on GitHub</a>

          <h1 id="project_title">PyShark</h1>
          <h2 id="project_tagline">Python packet parser using wireshark&#39;s tshark</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/KimiNewt/pyshark/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/KimiNewt/pyshark/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="pyshark" class="anchor" href="#pyshark" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>pyshark</h1>

<p>Python wrapper for tshark, allowing python packet parsing using wireshark dissectors.</p>

<p>There are quite a few python packet parsing modules, this one is different because it doesn't actually parse any packets, it simply uses tshark's (wireshark command-line utility) ability to export XMLs to use its parsing.</p>

<p>This package allows parsing from a capture file or a live capture, using all wireshark dissectors you have installed.
Tested on windows/linux.</p>

<h1>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h1>

<p>Pyshark features a few "Capture" objects (Live, Remote, File, InMem). Each of those files read from their respective source and then can be used as an iterator to get their packets. Each capture object can also receive various filters so that only some of the incoming packets will be saved.</p>

<h2>
<a id="reading-from-a-capture-file" class="anchor" href="#reading-from-a-capture-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reading from a capture file:</h2>

<div class="highlight highlight-source-python"><pre><span class="pl-k">import</span> pyshark
cap <span class="pl-k">=</span> pyshark.FileCapture(<span class="pl-s"><span class="pl-pds">'</span>/tmp/mycapture.cap<span class="pl-pds">'</span></span>)
cap
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">&lt;</span>FileCapture <span class="pl-k">/</span>tmp<span class="pl-k">/</span>mycapture.cap<span class="pl-k">&gt;</span>
<span class="pl-c1">print</span> cap[<span class="pl-c1">0</span>]
Packet (Length: <span class="pl-c1">698</span>)
Layer <span class="pl-c1">ETH</span>:
        Destination: aa:bb:cc:dd:ee:ff
        Source: <span class="pl-c1">00</span>:de:ad:be:ef:<span class="pl-c1">00</span>
        Type: IP (<span class="pl-c1"><span class="pl-k">0x</span>0800</span>)
Layer <span class="pl-c1">IP</span>:
        Version: <span class="pl-c1">4</span>
        Header Length: <span class="pl-c1">20</span> <span class="pl-c1">bytes</span>
        Differentiated Services Field: <span class="pl-c1"><span class="pl-k">0x</span>00</span> (<span class="pl-c1">DSCP</span> <span class="pl-c1"><span class="pl-k">0x</span>00</span>: Default; <span class="pl-c1">ECN</span>: <span class="pl-c1"><span class="pl-k">0x</span>00</span>: Not<span class="pl-k">-</span>ECT (Not <span class="pl-c1">ECN</span><span class="pl-k">-</span>Capable Transport))
        Total Length: <span class="pl-c1">684</span>
        Identification: <span class="pl-c1"><span class="pl-k">0x</span>254f</span> (<span class="pl-c1">9551</span>)
        Flags: <span class="pl-c1"><span class="pl-k">0x</span>00</span>
        Fragment offset: <span class="pl-c1">0</span>
        Time to live: <span class="pl-c1">1</span>
        Protocol: UDP (<span class="pl-c1">17</span>)
        Header checksum: <span class="pl-c1"><span class="pl-k">0x</span>e148</span> [correct]
        Source: <span class="pl-c1">192.168</span>.0.1
        Destination: <span class="pl-c1">192.168</span>.0.2
  <span class="pl-c1">...</span></pre></div>

<h2>
<a id="reading-from-a-live-interface" class="anchor" href="#reading-from-a-live-interface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reading from a live interface:</h2>

<div class="highlight highlight-source-python"><pre>capture <span class="pl-k">=</span> pyshark.LiveCapture(<span class="pl-v">interface</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>)
capture.sniff(<span class="pl-v">timeout</span><span class="pl-k">=</span><span class="pl-c1">50</span>)
capture
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-k">&lt;</span>LiveCapture (<span class="pl-c1">5</span> packets)<span class="pl-k">&gt;</span>
capture[<span class="pl-c1">3</span>]
<span class="pl-k">&lt;</span><span class="pl-c1">UDP</span><span class="pl-k">/</span><span class="pl-c1">HTTP</span> Packet<span class="pl-k">&gt;</span>

<span class="pl-k">for</span> packet <span class="pl-k">in</span> capture.sniff_continuously(<span class="pl-v">packet_count</span><span class="pl-k">=</span><span class="pl-c1">5</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Just arrived:<span class="pl-pds">'</span></span>, packet</pre></div>

<p>Capturing from a live interface can be done in two ways: either using the <em>sniff()</em> method to capture a given amount of packets (or for a given amount of time) and then read the packets from the capture object as a list, or use the <em>sniff_continously()</em> method as a generator and work on each packet as it arrives. Another alternative is defining a callback for each received packet:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">print_callback</span>(<span class="pl-smi">pkt</span>):
    <span class="pl-c1">print</span> <span class="pl-s"><span class="pl-pds">'</span>Just arrived:<span class="pl-pds">'</span></span>, pkt
capture.apply_on_packets(print_callback, <span class="pl-v">timeout</span><span class="pl-k">=</span><span class="pl-c1">5</span>)</pre></div>

<p>The capture can also run on multiple interfaces if a list is provided, or all interfaces if no interface is provided. It can even be run through a remote interface using <em>RemoteCapture</em>.</p>

<h2>
<a id="filtering-packets" class="anchor" href="#filtering-packets" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filtering packets:</h2>

<p>Filtering packets can be done with any capture object, like so:</p>

<div class="highlight highlight-source-python"><pre>filtered_cap <span class="pl-k">=</span> pyshark.FileCapture(path_to_file, <span class="pl-v">display_filter</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>http<span class="pl-pds">'</span></span>)
filtered_cap2 <span class="pl-k">=</span> pyshark.LiveCapture(<span class="pl-s"><span class="pl-pds">'</span>eth0<span class="pl-pds">'</span></span>, <span class="pl-v">bpf_filter</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>tcp port 80<span class="pl-pds">'</span></span>)</pre></div>

<p>There are two types of filters, <strong>BPF filters</strong> and <strong>display filters</strong>. Generally, bpf filters are more limited but are faster while display filters can be used on pretty much any attribute of the packet but are much slower. (Note: there is currently an <a href="https://github.com/KimiNewt/pyshark/issues/69">issue</a> with BPF filters on FileCapture and it is not recommended it be used).</p>

<p>See BPF syntax help <a href="http://biot.com/capstats/bpf.html">here</a> and display filters help <a href="http://wiki.wireshark.org/DisplayFilters">here</a>.</p>

<h2>
<a id="accessing-packet-data" class="anchor" href="#accessing-packet-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Accessing packet data:</h2>

<p>Data can be accessed in multiple ways. 
Packets are divided into layers, first you have to reach the appropriate layer and then you can select your field.</p>

<p>All of the following work:</p>

<div class="highlight highlight-source-python"><pre>packet[<span class="pl-s"><span class="pl-pds">'</span>ip<span class="pl-pds">'</span></span>].dst <span class="pl-c"># By protocol string</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">192.168</span>.0.1
packet.ip.src <span class="pl-c"># By protocol attribute</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">192.168</span>.0.100
packet[<span class="pl-c1">2</span>].src <span class="pl-c"># By layer index</span>
<span class="pl-k">&gt;&gt;</span><span class="pl-k">&gt;</span> <span class="pl-c1">192.168</span>.0.100</pre></div>

<p>To easily view the different attributes of the layer, you can simply run <em>dir(packet.my_layer)</em> or even print it or use the special <em>pretty_print()</em> method both layer and packet have.
Note that all attributes return as strings at the moment.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">PyShark maintained by <a href="https://github.com/KimiNewt">KimiNewt</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
