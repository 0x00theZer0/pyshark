{"name":"PyShark","tagline":"Python packet parser using wireshark's tshark","body":"pyshark\r\n=======\r\n\r\nPython wrapper for tshark, allowing python packet parsing using wireshark dissectors.\r\n\r\nThere are quite a few python packet parsing modules, this one is different because it doesn't actually parse any packets, it simply uses tshark's (wireshark command-line utility) ability to export XMLs to use its parsing.\r\n\r\nThis package allows parsing from a capture file or a live capture, using all wireshark dissectors you have installed.\r\nTested on windows/linux.\r\n\r\nUsage\r\n=====\r\n\r\nPyshark features a few \"Capture\" objects (Live, Remote, File). Each of those files read from their respective source and then can be used as an iterator to get their packets. Each capture object can also receive various filters so that only some of the incoming packets will be saved.\r\n\r\nReading from a capture file:\r\n----------------------------\r\n\r\n```python\r\nimport pyshark\r\ncap = pyshark.FileCapture('/tmp/mycapture.cap')\r\ncap\r\n>>> <FileCapture /tmp/mycapture.cap (589 packets)>\r\nprint cap[0]\r\nPacket (Length: 698)\r\nLayer ETH:\r\n        Destination: BLANKED\r\n        Source: BLANKED\r\n        Type: IP (0x0800)\r\nLayer IP:\r\n        Version: 4\r\n        Header Length: 20 bytes\r\n        Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))\r\n        Total Length: 684\r\n        Identification: 0x254f (9551)\r\n        Flags: 0x00\r\n        Fragment offset: 0\r\n        Time to live: 1\r\n        Protocol: UDP (17)\r\n        Header checksum: 0xe148 [correct]\r\n        Source: BLANKED\r\n        Destination: BLANKED\r\n  ...\r\n```\r\n  \r\nReading from a live interface:\r\n------------------------------\r\n\r\n```python\r\ncapture = pyshark.LiveCapture(interface='eth0')\r\ncapture.sniff(timeout=50)\r\ncapture\r\n>>> <LiveCapture (5 packets)>\r\ncapture[3]\r\n<UDP/HTTP Packet>\r\n\r\nfor packet in capture.sniff_continuously(packet_count=5):\r\n    print 'Just arrived:', packet\r\n```\r\n\r\nCapturing from a live interface can be done in two ways: either using the _sniff()_ method to capture a given amount of packets (or for a given amount of time) and then read the packets from the capture object as a list, or use the _sniff_continously()_ method as a generator and work on each packet as it arrives.\r\n\r\nThe capture can also run on multiple interfaces if a list is providing, or all interfaces if no interface is provided. It can even be run through a remote interface using _RemoteCapture_.\r\n\r\nFiltering packets:\r\n------------------\r\n\r\nFiltering packets can be done with any capture object, like so:\r\n\r\n```python\r\nfiltered_cap = pyshark.FileCapture(bpf_filter='tcp port 80')\r\nfiltered_cap2 = pyshark.LiveCapture(display_filter='http')\r\n```\r\n\r\nThere are two types of filters, **BPF filters** and **display filters**. Generally, bpf filters are more limited but are faster while display filters can be used on pretty much any attribute of the packet but are much slower.\r\n\r\nSee BPF syntax help [here](http://biot.com/capstats/bpf.html) and display filters help [here](http://wiki.wireshark.org/DisplayFilters).\r\n\r\nAccessing packet data:\r\n----------------------\r\n\r\nData can be accessed in multiple ways. \r\nPackets are divided into layers, first you have to reach the appropriate layer and then you can select your field.\r\n\r\nAll of the following work:\r\n\r\n```python\r\npacket['ip'].dst\r\n>>> 192.168.0.1\r\npacket.ip.src\r\n>>> 192.168.0.100\r\npacket[2].src\r\n>>> 192.168.0.100\r\n```\r\n\r\nTo easily view the different attributes of the layer, you can simply run _dir(packet.my_layer)_ or even print it or use the special _pretty_print()_ method both layer and packet have.\r\nNote that all attributes return as strings at the moment.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}